<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Aided Drafting: Robot Aided Drafting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Robot Aided Drafting
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Robot Aided Drafting </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md0"></a>
Table of Contents</h2>
<ol type="1">
<li>Overview <br  />
</li>
<li>Major Hardware <br  />
</li>
<li>Software Implementation <br  />
</li>
<li>Mathematical and Physical Modeling <br  />
</li>
<li>Appendix, Future Work, and Final Notes <br  />
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1"></a>
1. Overview</h2>
<p>This report summarizes the design, implementation, and validation of our 3 DoF plotter robot arm for ME-507. The system combines mechanical fabrication, embedded firmware on an STM32F411, and high-level preprocessing/postprocessing scripts in Python and MATLAB to convert drawings into smooth joint trajectories.</p>
<p><b>Mechanical system</b></p>
<ul>
<li><b>Links &amp; joints:</b> Two revolute joints (θ₁, θ₂) plus one prismatic “pen” servo (Z-axis).</li>
<li><b>Actuators:</b> NEMA-23 and -17 stepper motors (1/32 microstep) for the two rotary joints, and a 5 mm-throw servo for pen up/down.</li>
<li><b>Structure:</b> 3D-printed link bodies with carbon-fiber stiffening rods (space reserved here for a CAD rendering).</li>
</ul>
<p><b>Figure 1‑1. Physical prototype of the 3 DOF plotter arm</b> <br  />
</p>
<p><img src="Robot_Arm.jpg" alt="Robo Arm" width="600px" class="inline"/></p>
<p><b>Firmware &amp; control</b></p>
<ul>
<li><b>Microcontroller:</b> STM32F411CEU6 running HAL-based C code (STM32CubeIDE).</li>
<li><b>Motion engine:</b><ul>
<li>Homing via dual limit switches</li>
<li>Catmull–Rom spline interpolation between waypoints</li>
<li>Timer-driven step pulses on TIM3, servo PWM on TIM1</li>
</ul>
</li>
<li><b>Safety &amp; sensing:</b> Ultrasonic sensor for obstruction detection (HC-SR04) and “kill switch” via user button</li>
</ul>
<p><b>High-level preprocessing</b></p>
<ul>
<li>Python code (<code><a class="el" href="">ImageToAngles.py</a></code>):<ol type="1">
<li>Raster → binarize → skeletonize</li>
<li>Depth-first graph walk to extract pixel path</li>
<li>Down-sample (–px-skip, –min-dist) to control point count</li>
<li>Inverse kinematics → <code>{θ₁, θ₂, z}</code> list</li>
</ol>
</li>
</ul>
<p><b>Validation &amp; plotting</b></p>
<ul>
<li>MATLAB code (<code><a class="el" href="">verify_angles.mlx</a></code>):<ul>
<li>Forward kinematics of each <code>{θ₁, θ₂}</code> pair</li>
<li>Overlay on original image to verify fidelity</li>
<li>Generate 2D trajectory plots</li>
</ul>
</li>
</ul>
<p>We found that simple contour extraction produced thick “bubbles,” so we switched to skeleton thinning to get a single-pixel path.</p>
<p><b>Figure 1‑2. MATLAB validation path showing sketch shape</b> <br  />
</p>
<p><img src="matlab_plot.png" alt="Figure 2: MATLAB validation plot" width="600px" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md2"></a>
2. Major Hardware</h2>
<h4><a class="anchor" id="autotoc_md3"></a>
2.1 Design of the Robot / Contraption</h4>
<p>The plotter is a planar arm with <b>two revolute joints</b> (θ₁, θ₂) and a <b>prismatic Z-axis</b> for pen lift. Key design decisions:</p>
<ul>
<li><b>Planar 3-DOF geometry</b> → simple IK and no wrist singularity <br  />
</li>
<li><b>SolidWorks &amp; Fusion 360 CAD</b> for precise bearing, motor-flange, and sensor alignment <br  />
</li>
<li><b>3D‑printed PLA links</b> (L₁ ≈ 150 mm, L₂ ≈ 140 mm) with embedded carbon‑fiber rods <br  />
</li>
<li>Integrated bosses for <b>limit-switch brackets</b> and cable routing <br  />
</li>
</ul>
<p><b>Figure 2‑1. CAD rendering of the 3-DOF plotter arm and base</b> <br  />
</p>
<p><img src="CAD_Assem.png" alt="Figure x: Solidworks Assembly" width="600px" class="inline"/></p>
<p><b>Joint layout</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Axis   </th><th class="markdownTableHeadNone">Actuator   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">θ₁ (Base)   </td><td class="markdownTableBodyNone">NEMA‑23 stepper   </td><td class="markdownTableBodyNone">2.8 Nm holding; drives full arm sweep    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">θ₂ (Elbow)   </td><td class="markdownTableBodyNone">NEMA‑17 stepper   </td><td class="markdownTableBodyNone">0.59 Nm holding; drives fore‑arm link    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Z (Pen)   </td><td class="markdownTableBodyNone">5 V Servo   </td><td class="markdownTableBodyNone">Rack‑and‑pinion pen lift   </td></tr>
</table>
<p>Constraints: elbow backlash, 180° servo throw, and torque at full extension.</p>
<hr  />
<h4><a class="anchor" id="autotoc_md5"></a>
2.2 Motors and Actuators</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Joint   </th><th class="markdownTableHeadNone">Motor   </th><th class="markdownTableHeadNone">Driver   </th><th class="markdownTableHeadNone">Current   </th><th class="markdownTableHeadNone">Resolution   </th><th class="markdownTableHeadNone">Comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">θ₁   </td><td class="markdownTableBodyNone">NEMA‑23   </td><td class="markdownTableBodyNone">DRV8825   </td><td class="markdownTableBodyNone">1.5 A   </td><td class="markdownTableBodyNone">6400 µsteps/rev   </td><td class="markdownTableBodyNone">1/32 step    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">θ₂   </td><td class="markdownTableBodyNone">NEMA‑17   </td><td class="markdownTableBodyNone">DRV8825   </td><td class="markdownTableBodyNone">1.2 A   </td><td class="markdownTableBodyNone">6400 µsteps/rev   </td><td class="markdownTableBodyNone">1/32 step    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Z   </td><td class="markdownTableBodyNone">5 V Servo   </td><td class="markdownTableBodyNone">TIM1 PWM   </td><td class="markdownTableBodyNone">—   </td><td class="markdownTableBodyNone">1 ms–2 ms pulse   </td><td class="markdownTableBodyNone">Pen lift   </td></tr>
</table>
<ul>
<li><b>Stepping</b>: 2 kHz for drawing, 4 kHz for homing <br  />
</li>
<li><b>Servo PWM</b>: TIM1‑Ch2 @ 50 Hz <br  />
</li>
</ul>
<hr  />
<h4><a class="anchor" id="autotoc_md7"></a>
2.3 Sensors</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Sensor   </th><th class="markdownTableHeadNone">Mount   </th><th class="markdownTableHeadNone">Purpose   </th><th class="markdownTableHeadNone">MCU Pin(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">HC‑SR04   </td><td class="markdownTableBodyNone">Z‑frame   </td><td class="markdownTableBodyNone">Halt if distance &lt; 35 mm   </td><td class="markdownTableBodyNone">TRIG PB4, ECHO PB3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Limit Switch 1   </td><td class="markdownTableBodyNone">Base   </td><td class="markdownTableBodyNone">Home θ₁   </td><td class="markdownTableBodyNone">PB6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Limit Switch 2   </td><td class="markdownTableBodyNone">Elbow   </td><td class="markdownTableBodyNone">Home θ₂   </td><td class="markdownTableBodyNone">PB7    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FSR   </td><td class="markdownTableBodyNone">Pen carriage   </td><td class="markdownTableBodyNone">Contact force   </td><td class="markdownTableBodyNone">ADC Pin   </td></tr>
</table>
<p><b>Ultrasonic timing</b></p>
<div class="fragment"><div class="line">uint32_t start = DWT-&gt;CYCCNT;</div>
<div class="line"><span class="keywordflow">while</span> (HAL_GPIO_ReadPin(ECHO_Port,ECHO_Pin)==GPIO_PIN_SET);</div>
<div class="line">uint32_t end   = DWT-&gt;CYCCNT;</div>
<div class="line"><span class="keywordtype">float</span> dt_us = (end-start) * (1e6f / HAL_RCC_GetHCLKFreq());</div>
<div class="line"><span class="keywordtype">float</span> distance = dt_us*0.343f/2.0f;</div>
<div class="line"><span class="keywordflow">if</span> (distance &lt; 35.0f) motorsDisable();</div>
</div><!-- fragment --><p>Mechanical switches are NC style; debounced via <code>debouncedSwitchPressed()</code>. <br  />
 FSR channel was omitted on this PCB; planned for Rev‑B.</p>
<hr  />
<h4><a class="anchor" id="autotoc_md9"></a>
2.4 Custom PCB and Electrical Considerations</h4>
<p>Our custom four-layer PCB is centered on a 12 V “VS” bus, distributed via a plated-through power plane and fused by a 5 A resettable polyfuse (F1). The incoming 12 V is protected against reverse polarity by a P-channel MOSFET (NTMS4177PR2G): the gate was originally mis-wired to the source plane (so the board would never power on), but was corrected by wiring it to ground. We also had to change the Not ON or OFF pin on the buck regulator (VR1). <br  />
</p>
<p><b>Figure 2-2. 3D image of assembled 4‑layer PCB</b></p>
<p><img src="PCB_Assembly.PNG" alt="Assembled PCB" width="700px" class="inline"/></p>
<ul>
<li>4‑layer board with 12 V <b>VS</b> bus, 5 A polyfuse, and PFET reverse‑polarity switch <br  />
</li>
<li>LM2576HV buck (12 V→5 V) and NCP1117 LDO (5 V→3.3 V)</li>
</ul>
<p><b>Figure 2-3. Voltage regulators and MCU schematic</b></p>
<p><img src="board_schematic.PNG" alt="Voltage & MCU schematic" width="700px" class="inline"/></p>
<ul>
<li>STM32F411CEU6, SWD header, UART debug, status LED <br  />
</li>
<li>Two DRV8825 modules: 0.25 Ω sense, 1/32 step, fault LEDs <br  />
</li>
</ul>
<p><b>Figure 2‑4. DRV8825 stepper‑driver schematic</b> <br  />
</p>
<p><img src="driver_schematic.PNG" alt="DRV8825 schematic" width="700px" class="inline"/></p>
<p><b>Figure 2‑5. Board Layout</b> <br  />
</p>
<p><img src="pcb_layout.PNG" alt="PCB Layout" width="700px" class="inline"/></p>
<hr  />
<h2><a class="anchor" id="autotoc_md11"></a>
3. Software Implementation</h2>
<p>Our software stack is divided into three layers:</p>
<ol type="1">
<li><b>Embedded C Firmware</b> on the STM32F411CEU6 <br  />
</li>
<li><b>Python Preprocessor</b> (<code><a class="el" href="">ImageToAngles.py</a></code>) <br  />
</li>
<li><b>MATLAB Validation Script</b> (<code><a class="el" href="">verify_angles.mlx</a></code>) <br  />
</li>
</ol>
<p>Each layer has a clear role—desktop tools handle heavy image and kinematic computation, and the MCU firmware executes a precomputed, collision-safe motion plan in real time.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md13"></a>
3.1 Embedded C Firmware (STM32CubeIDE)</h3>
<h4><a class="anchor" id="autotoc_md14"></a>
3.1.1 <code>main.c</code> Workflow</h4>
<div class="fragment"><div class="line"><span class="comment">// Initialization</span></div>
<div class="line">HAL_Init();</div>
<div class="line"><a class="code hl_function" href="main_8c.html#a70af21c671abfcc773614a9a4f63d920">SystemClock_Config</a>();</div>
<div class="line">MX_GPIO_Init();</div>
<div class="line">MX_TIM1_Init();   <span class="comment">// Servo PWM</span></div>
<div class="line">MX_TIM3_Init();   <span class="comment">// Stepper pulses</span></div>
<div class="line">MX_TIM5_Init();   <span class="comment">// Reserved</span></div>
<div class="line">sensorInit();     <span class="comment">// HC-SR04 TRIG/ECHO</span></div>
<div class="line">HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_2);</div>
<div class="line">motorsHome();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Main loop</span></div>
<div class="line"><span class="keywordflow">while</span> (1) {</div>
<div class="line">    <span class="keywordflow">if</span> (!motorsRunSplinePlan(plan, plan_length)) <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="comment">// Obstruction handling</span></div>
<div class="line">    <span class="keywordflow">while</span> (obstruction()) {</div>
<div class="line">        motorsDisable();</div>
<div class="line">        __WFI();</div>
<div class="line">    }</div>
<div class="line">    motorsEnable();</div>
<div class="line">}</div>
<div class="line">motorsHome();</div>
<div class="line">motorsDisable();</div>
<div class="ttc" id="amain_8c_html_a70af21c671abfcc773614a9a4f63d920"><div class="ttname"><a href="main_8c.html#a70af21c671abfcc773614a9a4f63d920">SystemClock_Config</a></div><div class="ttdeci">void SystemClock_Config(void)</div><div class="ttdoc">System Clock Configuration.</div><div class="ttdef"><b>Definition</b> main.c:162</div></div>
</div><!-- fragment --><ul>
<li><b>DWT cycle counter</b> enabled for microsecond timing in <code><a class="el" href="us__sensor_8c.html" title="Ultrasonic distance sensor (HC‑SR04) driver utilities.">us_sensor.c</a></code>. <br  />
</li>
<li><b>2 Limit switches</b> on PB6, PB7 for homing. <br  />
</li>
<li><b>Ultrasonic sensor</b> triggers immediate motor disable if an object is detected within 35 mm. <br  />
</li>
</ul>
<h4><a class="anchor" id="autotoc_md15"></a>
3.1.2 Motion Engine (<code>motors.c</code>)</h4>
<ul>
<li><b>Microstepping</b> at 1/32 (200 steps × 32) giving ~17.8 µsteps/°: <br  />
 <div class="fragment"><div class="line"><span class="preprocessor">#define STEPS_PER_DEG1  (200.0f * 32.0f / 360.0f)</span></div>
<div class="line"><span class="preprocessor">#define STEPS_PER_DEG2  (200.0f * 32.0f / 360.0f)</span></div>
</div><!-- fragment --></li>
<li><b>Homing</b>: <br  />
<ul>
<li>Drive both steppers toward limit switches at 4 kHz <br  />
</li>
<li>Debounce via <code>debouncedSwitchPressed()</code> <br  />
</li>
</ul>
</li>
<li><b>Drawing</b>: <br  />
<ul>
<li>Build Catmull–Rom tangents (<code>buildTangents()</code>) <br  />
</li>
<li>For each segment, subdivide based on max Δθ = 0.05° <br  />
</li>
<li>Interpolate with <code>hermite()</code> <br  />
</li>
<li>Call <code>newsendJointAngles(θ₁, θ₂, Z)</code> which: <br  />
<ul>
<li>Raises/lowers pen (<code>moveServoPulse()</code>) <br  />
</li>
<li>Computes step counts and direction pins <br  />
</li>
<li>Starts TIM3 compare interrupts <br  />
</li>
<li>Polls <code>steps_remaining</code> in a WFI loop until both axes are done <br  />
</li>
</ul>
</li>
</ul>
</li>
<li><b>Interrupt-driven stepping</b> in <code>MOT_TIM3_IRQHandler()</code>: <br  />
<ul>
<li>Toggles STEP pins at 50% duty <br  />
</li>
<li>Decrements <code>steps_remaining</code> on each LOW edge <br  />
</li>
<li>Stops channel when done <br  />
</li>
</ul>
</li>
</ul>
<p>This design uses <b>static arrays</b> for spline buffers (no dynamic memory) and <b>timer interrupts</b> for precise pulse timing, ensuring smooth, blocking-free motion.</p>
<hr  />
 <h4><a class="anchor" id="autotoc_md17"></a>
3.1.5 Workspace Mapping &amp; Offset Angle Image To Angles Python (<code>ImageToAngles.py</code>)</h4>
<p><code><a class="el" href="">ImageToAngles.py</a></code> embeds the robot’s physical dimensions so every drawing is rescaled into a <b>safe, reachable workspace</b> before inverse kinematics:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Constant   </th><th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Purpose    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>L1</code>, <code>L2</code>   </td><td class="markdownTableBodyNone">5.816 in, 5.931 in   </td><td class="markdownTableBodyNone">Link lengths used for IK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>OFFSET_T2_DEG</code>   </td><td class="markdownTableBodyNone"><b>+147.5 °</b>   </td><td class="markdownTableBodyNone">Offset so θ₂ = 0° aligns the elbow with the +X axis    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>X_RANGE</code>   </td><td class="markdownTableBodyNone">(−6 in, −2 in)   </td><td class="markdownTableBodyNone">Allowed X‑span for normalized drawing    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Y_RANGE</code>   </td><td class="markdownTableBodyNone">( 5.5 in,  9 in)   </td><td class="markdownTableBodyNone">Allowed Y‑span for normalized drawing   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment"># Workspace constants inside ImageToAngles.py</span></div>
<div class="line">L1, L2 = 5.816, 5.931          <span class="comment"># inches</span></div>
<div class="line">OFFSET_T2_DEG = 147.5          <span class="comment"># elbow mechanical zero offset</span></div>
<div class="line">X_RANGE = (-6, -2)             <span class="comment"># inches</span></div>
<div class="line">Y_RANGE = ( 5.5,  9)</div>
</div><!-- fragment --><p>During <b>normalization</b> every pixel point is uniformly scaled and translated:</p>
<div class="fragment"><div class="line">sx = (X_RANGE[1] - X_RANGE[0]) / (max(xs) - min(xs))</div>
<div class="line">sy = (Y_RANGE[1] - Y_RANGE[0]) / (max(ys) - min(ys))</div>
<div class="line">s  = min(sx, sy)               <span class="comment"># keep aspect ratio</span></div>
<div class="line">x<span class="stringliteral">&#39; = (x - cx) * s + tx         # center &amp; scale</span></div>
<div class="line"><span class="stringliteral">y&#39; = (y - cy) * s + ty</span></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md18"></a>
This guarantees all generated waypoints fall inside the robot’s reachable XY envelope, while <code>OFFSET_T2_DEG</code> aligns the computed θ₂ with the actual elbow zero measured after assembly.</h2>
<h3><a class="anchor" id="autotoc_md19"></a>
3.2 Python Conversion (<code>ImageToAngles.py</code>)</h3>
<p>The Python script converts a PNG into a <code>{θ₁, θ₂, Z}</code> sequence:</p>
<ol type="1">
<li><b>Skeletonization</b> <br  />
 <div class="fragment"><div class="line">skel = skeletonize(bw &gt; 0)</div>
</div><!-- fragment --></li>
<li><b>Graph construction &amp; DFS</b> <br  />
<ul>
<li>Build 8-connected adjacency of skeleton pixels <br  />
</li>
<li>Depth-first traversal to produce an ordered path <br  />
</li>
<li>Insert <code>z=1</code> (pen-up) markers at stroke discontinuities <br  />
</li>
</ul>
</li>
<li><b>Normalization</b> <br  />
 <div class="fragment"><div class="line"># Uniformly scale into X_RANGE × Y_RANGE</div>
<div class="line">sx = (X2 - X1) / (max(xs)-min(xs))</div>
<div class="line">sy = (Y2 - Y1) / (max(ys)-min(ys))</div>
</div><!-- fragment --></li>
<li><b>Downsampling</b> <br  />
<ul>
<li><code>--px-skip N</code>: take every Nth point <br  />
</li>
<li><code>--min-dist D</code>: remove points closer than D inches <br  />
</li>
</ul>
</li>
<li><b>Inverse kinematics</b> <br  />
 <div class="fragment"><div class="line"><span class="keyword">def </span>ik_xy(x,y):</div>
<div class="line">    <span class="comment"># Law of Cosines + atan2, apply OFFSET_T2_DEG</span></div>
</div><!-- fragment --></li>
<li><b>Output</b>: writes <code>image_thetas.txt</code> in <br  />
 <div class="fragment"><div class="line">{θ1, θ2, z},</div>
<div class="line">{…},</div>
</div><!-- fragment --></li>
</ol>
<p>All parameters are exposed via <code>argparse</code>, making it easy to tune point density and workspace mapping.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md21"></a>
3.3 MATLAB Validation Script (<code>verify_angles.mlx</code>)</h3>
<p>The MATLAB live script:</p>
<ol type="1">
<li><b>Imports</b> the <code>{θ₁, θ₂, Z}</code> list <br  />
</li>
<li><b>Performs forward kinematics</b>: <br  />
 <div class="fragment"><div class="line">x = L1*cos(th1) + L2*cos(th1+th2-offset);</div>
<div class="line">y = L1*sin(th1) + L2*sin(th1+th2-offset);</div>
</div><!-- fragment --></li>
<li><b>Overlays</b> the computed trajectory on the original image <br  />
</li>
<li><b>Plots</b> time series of joint angles for debugging <br  />
</li>
<li><b>Exports</b> high-resolution figures for report inclusion <br  />
</li>
</ol>
<p>This feedback loop verifies that the Python IK and spline interpolation produce accurate, drawable paths before flashing the MCU.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md23"></a>
3.4 Integration &amp; Workflow</h3>
<ol type="1">
<li><b>Design &amp; export</b> sketch to PNG <br  />
</li>
<li><b>To run:</b> <code>!python <a class="el" href="">ImageToAngles.py</a> sketch.png [--px-skip N] [--min-dist D]</code> <br  />
</li>
<li><b>Validate</b> in MATLAB and adjust parameters <br  />
</li>
<li><b>Manually input</b> the resulting <code>{θ₁, θ₂, Z}</code> into <code><a class="el" href="joint__inputs_8c.html" title="Pre-generated motion plan for the SCARA plotter.">joint_inputs.c</a></code> <br  />
</li>
<li><b>Rebuild</b> and <b>flash</b> firmware via SWD <br  />
</li>
<li><b>Power on</b> and watch the arm autonomously home → draw → home <br  />
</li>
</ol>
<p>By offloading all heavy computation to desktop tools, the firmware remains a lean, real-time motion executor.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md25"></a>
3.5 Coding Style &amp; Organization</h3>
<ul>
<li><b>C++</b>: Procedural, module-based (<code><a class="el" href="main_8c.html" title="Top‑level application entry point and hardware initialization.">main.c</a></code>, <code><a class="el" href="motors_8c.html" title="Low‑level motion engine for stepper‑driven SCARA joints.">motors.c</a></code>, <code><a class="el" href="us__sensor_8c.html" title="Ultrasonic distance sensor (HC‑SR04) driver utilities.">us_sensor.c</a></code>) with minimal globals and no heap. <br  />
</li>
<li><b>Interrupts</b>: Only for step pulses; main loop sleeps (<code>__WFI()</code>) between moves. <br  />
</li>
<li><b>Python</b>: Functional style with type hints, NumPy, and scikit-image for reliable image operations. <br  />
</li>
<li><b>MATLAB</b>: Live script combining code, narrative, and figures for rapid iteration.</li>
</ul>
<p>This clear separation of concerns ensures maintainability and ease of tuning.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
4. Mathematical and Physical Modeling</h2>
<hr  />
<h3><a class="anchor" id="autotoc_md28"></a>
4.1 Workspace Calculations</h3>
<p>We calculated the workspace of our robot using measurements from the solidworks model to find where to draw.</p>
<p><b>Figure 4-1. Workspace Calculations</b></p>
<p><img src="workspace.png" alt="Workspace Calculations" width="800px" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md29"></a>
4.2 Forward and Inverse Kinematics</h3>
<h4><a class="anchor" id="autotoc_md30"></a>
Inverse Kinematics</h4>
<p>To convert each image pixel (x,y) into joint angles {θ₁,θ₂}, we use a 2-link planar-arm model. Given link lengths L₁ and L₂, the Law of Cosines provides θ₂, and θ₁ is found via arctangent functions with a fixed servo offset of +147.5° applied to θ₂. We also flag a “pen-up” when consecutive waypoint distances exceed a configurable threshold.</p>
<h4><a class="anchor" id="autotoc_md31"></a>
Forward Kinematics</h4>
<p>For validation in MATLAB, we reconstruct the end-effector (x,y) path from {θ₁,θ₂}: </p><div class="fragment"><div class="line">x = L1*cos(th1) + L2*cos(th1 + th2 - deg2rad(offset));</div>
<div class="line">y = L1*sin(th1) + L2*sin(th1 + th2 - deg2rad(offset));</div>
</div><!-- fragment --><p> See appendix for the full code snippets. This confirms our planned trajectory matches the intended sketch.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md33"></a>
4.3 Trajectory Smoothing</h3>
<p>We employ Catmull–Rom spline interpolation on the joint-angle sequence, enforcing a maximum angular step of Δθ ≤ 0.05°. This ensures:</p><ul>
<li>Smooth curvature that still passes through each node</li>
<li>Consistent velocity profiles without sudden direction changes</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md35"></a>
4.4 Subsampling and Filtering</h3>
<p>Our Python preprocessor offers:</p><ul>
<li><code>--px-skip N</code>: Keeps only every Nth pixel, reducing waypoints.</li>
<li><code>--min-dist D</code>: Removes points closer than D mm in real-world space. To reduce overlapping contours that force the robot to go over the same section twice.</li>
</ul>
<p><b>Benefits:</b></p><ul>
<li>Reduces MCU execution time</li>
<li>Lowers mechanical wear by avoiding micro-jitter</li>
<li>Preserves essential path fidelity</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md37"></a>
4.5 Sensor Data Interpretation</h3>
<h4><a class="anchor" id="autotoc_md38"></a>
Ultrasonic Rangefinder</h4>
<p>We measure echo round-trip time using the STM32 DWT cycle counter, then compute distance. If distance &lt; 35 mm, the draw routine halts immediately.</p>
<h4><a class="anchor" id="autotoc_md39"></a>
Force-Sensing Resistor (FSR)</h4>
<p>Though not wired in this prototype, the design reads FSR voltage on an ADC channel at 1 Msps, applies a moving-average filter, and triggers a pen-lift when pressure exceeds a set threshold.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md41"></a>
Appendix: Code Snippets</h2>
<div class="fragment"><div class="line"><span class="comment"># Inverse kinematics (Python)</span></div>
<div class="line">cos_theta2 = (x**2 + y**2 - L1**2 - L2**2) / (2*L1*L2)</div>
<div class="line">theta2    = arccos(cos_theta2)</div>
<div class="line">k1        = L1 + L2*cos(theta2)</div>
<div class="line">k2        = L2*sin(theta2)</div>
<div class="line">theta1    = atan2(y, x) - atan2(k2, k1)</div>
</div><!-- fragment --><div class="fragment"><div class="line">% Forward kinematics (MATLAB)</div>
<div class="line">x = L1*cos(th1) + L2*cos(th1 + th2 - deg2rad(offset));</div>
<div class="line">y = L1*sin(th1) + L2*sin(th1 + th2 - deg2rad(offset));</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Ultrasonic sensor calculation (C)</span></div>
<div class="line">uint32_t dt_cycles = end - start;</div>
<div class="line"><span class="keywordtype">float</span>    dt_us     = dt_cycles * (1e6f / HAL_RCC_GetHCLKFreq());</div>
<div class="line"><span class="keywordtype">float</span>    distance_mm = dt_us * 0.343f / 2.0f;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md42"></a>
5. Appendix, Future Work, and Final Notes</h3>
<hr  />
<h4><a class="anchor" id="autotoc_md44"></a>
5.1 Files &amp; Code Structure</h4>
<p>Our repository is organized for clarity and reproducibility. Below is a high-level summary of key files:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Purpose    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="main_8c.html" title="Top‑level application entry point and hardware initialization.">main.c</a></code>   </td><td class="markdownTableBodyNone">Application entry point, homing, and path execution    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="motors_8c.html" title="Low‑level motion engine for stepper‑driven SCARA joints.">motors.c</a></code>   </td><td class="markdownTableBodyNone">Stepper control, servo actuation, spline planner    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="joint__inputs_8c.html" title="Pre-generated motion plan for the SCARA plotter.">joint_inputs.c</a></code>   </td><td class="markdownTableBodyNone">Precomputed list of <code>{θ₁, θ₂, Z}</code> steps    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="us__sensor_8c.html" title="Ultrasonic distance sensor (HC‑SR04) driver utilities.">us_sensor.c</a></code>   </td><td class="markdownTableBodyNone">Ultrasonic sensor for obstacle detection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="">ImageToAngles.py</a></code>   </td><td class="markdownTableBodyNone">Image → Skeleton → IK angles    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="">verify_angles.mlx</a></code>   </td><td class="markdownTableBodyNone">MATLAB trajectory validation via forward kinematics   </td></tr>
</table>
<p>All embedded code was built using STM32CubeIDE for the STM32F411CEU6 (Black Pill). Python and MATLAB were run offline during the image pre-processing and validation phases.</p>
<hr  />
<h4><a class="anchor" id="autotoc_md46"></a>
5.2 Future Improvements</h4>
<p>While our system performs well, several areas have clear upgrade paths:</p>
<ul>
<li><b>Improved prismatic Z actuator:</b> Current servo has limited throw. Using a larger gear with a continuous servo would give greater range and responsiveness.</li>
<li><b>Upgrade to 1/64 or 1/128 microstepping drivers:</b> Would dramatically smooth curvature and fine details.</li>
<li><b>Increasing Traces to Motors:</b> Ensure current is not being limited by small traces.</li>
<li><b>Replace I-sens resistor:</b> Improve resistor dividors to optimize DRV8825 performance.</li>
<li><b>ADC-enabled pressure sensing:</b> Route spare STM32 ADC pins to header pads so force-sensitive resistors (FSRs) can be added. This would allow feedback when the pen contacts paper. Adding backup pins and test pins is always helpful. Add more ground pins than you think you need.</li>
<li><b>Better mechanical stiffness:</b> Current links show slight flex. A future version would use I-beam style 3D prints or laser-cut aluminum arms.</li>
</ul>
<hr  />
<h4><a class="anchor" id="autotoc_md48"></a>
5.3 Lessons Learned</h4>
<ul>
<li><b>PCB diligence never ends.</b> Even with ERC/DRC passes, we still mis-wired a PFET gate and left the FSR ADC trace un-routed. A second independent checklist—or a “design-for-assembly” peer review—would have caught both errors. <br  />
</li>
<li><b>Subsample wisely.</b> Too many waypoints produce audible jitter and lost steps; too few distort circles into octagons. Pixel-skip and distance-prune parameters must be tuned together. <br  />
</li>
<li><b>Mechanical play shows up in code.</b> Link flex and coupling backlash required a larger pen-up clearance and forced us to overshoot splines slightly to hit endpoints. <br  />
</li>
<li><b>Always budget torque.</b> The NEMA-17 elbow was borderline at full extension; upgrading to a higher-torque model or adding counterweights would improve repeatability.</li>
<li><b>Careful for Servo range</b> Our 180 ° micro-servo barely cleared the page; a leadscrew or longer rack would give more z-travel headroom. <br  />
</li>
<li><b>Version-control your firmware AND tool scripts.</b> A stray change to <code><a class="el" href="">ImageToAngles.py</a></code> broke an old drawing until we traced the commit. <br  />
</li>
<li><b>Document while you build.</b> Taking photos and jotting notes during each rework step made this final report far easier to assemble.</li>
</ul>
<hr  />
<h4><a class="anchor" id="autotoc_md50"></a>
5.4 Example Trajectory (Placeholder)</h4>
<div class="fragment"><div class="line"><span class="comment">// Sample {θ₁, θ₂, Z} output from Python preprocessing</span></div>
<div class="line">{-54.2, -42.4, 0},</div>
<div class="line">{-54.1, -41.8, 0},</div>
<div class="line">{-53.6, -41.2, 0},</div>
<div class="line">{-53.3, -40.5, 0},</div>
<div class="line">{-52.7, -39.3, 1},</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>This trajectory is plotted in MATLAB and used as input to the <code>motorsRunSplinePlan()</code> routine on the STM32.</p>
<hr  />
<h4><a class="anchor" id="autotoc_md52"></a>
5.5 Closing Remarks</h4>
<p>This project demonstrates a full-stack mechatronic system: from user-drawn images to precision mechanical output. It highlights not only motion planning and control but also system-level integration between firmware, mechanical design, and external software tools.</p>
<p>With additional refinement, this 3-DOF plotter could serve as the basis for low-cost CNC drawing bots, laser engravers, or educational robotics kits.</p>
<p>*/</p>
<ul>
<li></li>
</ul>
<h1><a class="anchor" id="authors_sec"></a>
Authors</h1>
<ul>
<li>Dylan Featherson, Tomas Franco, Charith Sunku</li>
<li>Cal Poly San Luis Obispo, ME 405 – Spring 2025 </li>
</ul>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
